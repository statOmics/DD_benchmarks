---
title: "Differential detection: simulation strategies"
author: "Jeroen Gilis"
date: "19/04/2023"
output:
    html_document:
      code_download: true    
      theme: cosmo
      toc: true
      toc_float: true
      highlight: tango
      number_sections: true
---

# Load libraries

```{r, message=FALSE, warning=FALSE}
library(DDCompanion)
library(scuttle)
library(edgeR)
library(pbapply)
library(harmonicmeanp)
library(stageR)
library(iCOBRA)
library(patchwork)
library(ggplot2)
library(muscat)
```

# Helper functions

```{r, include=FALSE}
DD_pb_glm <- function(object){
        
        # binarize the counts
        object_bin <- object
        assay(object_bin)[assay(object_bin)>=1] <- 1
        
        # aggregate
        pb_bin <- aggregateAcrossCells(object_bin, ids = object_bin$ind_cov)
        
        # wrangle
        bin_counts <- as.matrix(assay(pb_bin))
        cd <- colData(pb_bin)

        # compute offset
        offset <- colMeans(sweep(bin_counts, 2, cd$ncells, "/"))
        cd$logitOffset <- log(offset/(1-offset))
        
        # create formula
        formula <- ~ batch_cov + group_id
        full_formula <- as.formula(paste("cbind(succes,failure)",
                                         paste(formula, collapse = " "),
                                         "+ offset(logitOffset)"))
        
        # Fit QB-GLM with offset
        mod <- pbapply::pblapply(seq_len(nrow(bin_counts)), function(i){
            cd$succes <- bin_counts[i,]
            cd$failure <- cd$ncells - cd$succes
            mod <- glm(formula = full_formula,
                       family = "quasibinomial",
                       data = cd)
            return(mod)
        })
        
        # test coefficient of interest
        dfresid_mod <- sapply(mod, function(mod){mod$df.residual})
        sum_mod <- lapply(mod, summary)
        disp <- sapply(sum_mod, function(summod){summod$dispersion})
        beta <- sapply(sum_mod, function(summod){coef(summod)["group_idB",1]})
        var_unscaled <- sapply(sum_mod, function(summod){summod$cov.unscaled["group_idB","group_idB"]})
        
        # squeeze variance
        hlp <- limma::squeezeVar(var = disp,
                          df = dfresid_mod,
                          robust = FALSE)
        
        # Compute relevant statistics using squeezed variances
        df_post <- hlp$df.prior + dfresid_mod # posterior DF
        SE <- sqrt(var_unscaled * hlp$var.post) # SE based on squeezed dispersion
        t <- beta / SE # new t-stat
        pval <- pt(-abs(t), df_post) * 2 # new pval
        
        res <- data.frame(gene = rownames(bin_counts),
                          cluster_id = as.factor("ncM"),
                          logOdds = beta,
                          var_unscaled = var_unscaled,
                          dispersion = disp,
                          dispersion_sq = hlp$var.post,
                          df_prior = hlp$df.prior,
                          df_resid = dfresid_mod,
                          SE = SE,
                          t = t,
                          Wald = (beta^2)/SE,
                          PValue = pval,
                          FDR = p.adjust(pval, method = "BH"),
                          comparsion = "group_idB")
        rownames(res) <- rownames(object)
        
        return(res)
}
```

```{r, include=FALSE}
DE_pb_edgeR <- function(object){
    pb <- aggregateAcrossCells(object, ids = object$ind_cov)

    y <- DGEList(counts=assay(pb), samples=colData(pb))
    y <- calcNormFactors(y)
    design <- model.matrix(~ factor(batch_cov) + factor(mock_group), y$samples)
    y<-estimateDisp(y,design)
    fit <- glmQLFit(y,design,robust=T)
    
    res_DGE <- glmQLFTest(fit,coef = ncol(design))
    res_DGE$table$FDR <- p.adjust(res_DGE$table$PValue, method = "BH")
    
    return(res_DGE$table)
}
```

```{r, include=FALSE}
DD_option2 <- function(object, genes_to_change, frac_cells){
    
    hlp_a <- assay(object)[genes_to_change[1:(length(genes_to_change)/2)],object$mock_group=="A"]
    hlp_b <- assay(object)[genes_to_change[(length(genes_to_change)/2+1):length(genes_to_change)],object$mock_group=="B"]
    
    vec_zero <- c(round(rowSums(hlp_a > 0) * frac_cells) , 
                  round(rowSums(hlp_b > 0) * frac_cells))
    
    for (i in 1:nrow(hlp_a)) {
        nonzero <- which(hlp_a[i,] > 0)
        n_zero <- round(length(nonzero)*frac_cells)
        count_vec <- sort(hlp_a[i,names(nonzero)])
        hlp_a[i,names(count_vec)[1:n_zero]] <- 0
    }
    
    for (i in 1:nrow(hlp_b)) {
        nonzero <- which(hlp_b[i,] > 0)
        n_zero <- round(length(nonzero)*frac_cells)
        count_vec <- sort(hlp_b[i,names(nonzero)])
        hlp_b[i,names(count_vec)[1:n_zero]] <- 0
    }

    assay(object)[rownames(hlp_a),object$mock_group=="A"] <- hlp_a
    assay(object)[rownames(hlp_b),object$mock_group=="B"] <- hlp_b
    
    rowData(object)$ncells_zero <- NA
    rowData(object[names(vec_zero),])$ncells_zero_2 <- vec_zero
    rowData(object[names(vec_zero),])$is_DE <- TRUE
    return(object)
}
```

```{r, include=FALSE}
DD_option3 <- function(object, genes_to_change, frac_cells){
    
    hlp_a <- assay(object)[genes_to_change[1:(length(genes_to_change)/2)],object$mock_group=="A"]
    hlp_b <- assay(object)[genes_to_change[(length(genes_to_change)/2+1):length(genes_to_change)],object$mock_group=="B"]
    
    vec_zero <- c(round(rowSums(hlp_a > 0) * frac_cells) , 
                  round(rowSums(hlp_b > 0) * frac_cells))
    
    for (i in 1:nrow(hlp_a)) {
        nonzero <- names(which(hlp_a[i,] > 0))
        n_zero <- round(length(nonzero)*frac_cells)
        
        # change some to zero
        change_to_zero <- sample(nonzero, n_zero)
        former_counts <- sum(unname(hlp_a[i,change_to_zero])) # store sum of counts set to zero
        hlp_a[i,change_to_zero] <- 0
        
        # add back the removed counts to the other cells
        not_change_to_zero <- nonzero[!nonzero %in% change_to_zero]
        hlp_add <- table(sample(not_change_to_zero,
                                former_counts,
                                replace = TRUE)) # redistribute the formerly removed counts
        hlp_a[i,names(hlp_add)] <- as.matrix(hlp_a[i,names(hlp_add)] + hlp_add)
    }
    
    for (i in 1:nrow(hlp_b)) {
        nonzero <- names(which(hlp_b[i,] > 0))
        n_zero <- round(length(nonzero)*frac_cells)
        
        # change some to zero
        change_to_zero <- sample(nonzero, n_zero)
        former_counts <- sum(unname(hlp_b[i,change_to_zero])) # store sum of counts set to zero
        hlp_b[i,change_to_zero] <- 0
        
        # add back the removed counts to the other cells
        not_change_to_zero <- nonzero[!nonzero %in% change_to_zero]
        hlp_add <- table(sample(not_change_to_zero,
                                former_counts,
                                replace = TRUE)) # redistribute the formerly removed counts
        hlp_b[i,names(hlp_add)] <- as.matrix(hlp_b[i,names(hlp_add)] + hlp_add)
    }

    assay(object)[rownames(hlp_a),object$mock_group=="A"] <- hlp_a
    assay(object)[rownames(hlp_b),object$mock_group=="B"] <- hlp_b
    
    rowData(object)$ncells_zero_3 <- NA
    rowData(object[names(vec_zero),])$ncells_zero_3 <- vec_zero
    rowData(object[names(vec_zero),])$is_DE <- TRUE
    return(object)
}
```

```{r, include=FALSE}
DD_option4 <- function(object, genes_to_change, frac_cells){
    
    hlp_a <- assay(object)[genes_to_change[1:(length(genes_to_change)/2)],object$mock_group=="A"]
    hlp_b <- assay(object)[genes_to_change[(length(genes_to_change)/2+1):length(genes_to_change)],object$mock_group=="B"]
    
    vec_add <- c(round(rowSums(hlp_a > 0) * frac_cells) , 
                 round(rowSums(hlp_b > 0) * frac_cells))
    
    for (i in 1:nrow(hlp_a)) {
        nonzero <- which(hlp_a[i,] > 0)
        n_add <- round(length(nonzero)*frac_cells)
        target <- names(sample(nonzero, n_add))
        hlp_a[i,target] <- hlp_a[i,target] + 1
    }
    
    for (i in 1:nrow(hlp_b)) {
        nonzero <- which(hlp_b[i,] > 0)
        n_add <- round(length(nonzero)*frac_cells)
        target <- names(sample(nonzero, n_add))
        hlp_b[i,target] <- hlp_b[i,target] + 1
    }
    
    assay(object)[rownames(hlp_a),object$mock_group=="A"] <- hlp_a
    assay(object)[rownames(hlp_b),object$mock_group=="B"] <- hlp_b
    
    rowData(object)$ncells_add <- NA
    rowData(object[names(vec_add),])$ncells_add <- vec_add
    rowData(object[names(vec_add),])$is_DE <- TRUE
    return(object)
}
```

```{r, include=FALSE}
visualize_fdrtpr <- function(DD_res, DE_res, truth){
    pvalues <- data.frame(QB_off_squeeze = DD_res$PValue,
                          edgeR_NB = DE_res$PValue)
    #screening stage
    pvalues$pScreen <- apply(X = pvalues, 
                             MARGIN = 1,
                             FUN = hmp.stat)
    rownames(pvalues) <- rownames(truth)
    cobra <- COBRAData(pval = pvalues, truth = truth)
    cobra <- calculate_adjp(cobra)
    cobraperf <- calculate_performance(cobra, 
                                       binary_truth = "is_DE", 
                                       splv = "none")
    cobraplot <- prepare_data_for_plot(cobraperf, 
                                       colorscheme = "Dark2", 
                                       facetted = TRUE)
    gg <- plot_fdrtprcurve(cobraplot) +
        theme(strip.background = element_blank(),
        strip.text.x = element_blank(),
        plot.title = element_text(size=10),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10))
    return(gg)
}
```

# Load data

```{r}
sce_list <- readRDS("./benchmarks/lupus/data/lupus-SCE_list-ncM-mock_replicates.rds")
```

# Introduce DD

```{r}
set.seed(628716)

# DD type 1: Introduce DD by swapping. This will also introduce DE.
object <- simulate_DE(x = sce_list[[1]], 
                      groups = sce_list[[1]]$mock_group, 
                      prop_DE = 1/40)
genes_to_change_1 <- rownames(object)[!is.na(rowData(object)$swapped_gene)]
object$group_id <- object$mock_group

# DD type 2
# Replace some of the counts with zeroes, but only do this for the lowest 
# counts. This will introduce both DD and DE, but the mean will be shifted less. 
# In practice, this will result in only 1's being set to zero.
# It could also correspond more closely to what happens in real life.

genes_to_change_2 <- sample(rownames(object)[!rowData(object)$is_DE],
                            nrow(object)/40)
object <- DD_option2(object = object,
                     genes_to_change = genes_to_change_2,
                     frac_cells = 0.25)

# DD type 3
# Again add zeroes in 1 mock group, but add the values that went to zero to
# other cells in that group. Thus, the mean will not be shifted (no DE). 
# However, the variance will shift, and we may end up generating bimodal 
# distributions.

genes_to_change_3 <- sample(rownames(object)[!rowData(object)$is_DE],
                            nrow(object)/40)
object <- DD_option3(object = object,
                     genes_to_change = genes_to_change_3,
                     frac_cells = 0.25)

# Introduce DE only
# Add a count of 1 to a fraction of the cells that already has a count?
genes_to_change_4 <- sample(rownames(object)[!rowData(object)$is_DE],
                            nrow(object)/40)
object <- DD_option4(object = object,
                     genes_to_change = genes_to_change_4,
                     frac_cells = 0.25)
```

# Run analysis

```{r}
# DD analysis on each dataset
res_DD_3 <- DD_pb_glm(object = object)

# DE analysis on each dataset
res_DE_3 <- DE_pb_edgeR(object = object)
```

# Visualize results

```{r}
# truth is the same for all datasets
truth <- data.frame(gene = rownames(object),
                    is_DE = rowData(object)$is_DE)
rownames(truth) <- truth$gene
mock <- truth$gene[!truth$is_DE]
```

```{r, message=FALSE, warning=FALSE}
gg_all <- visualize_fdrtpr(DD_res = res_DD_3, 
                           DE_res = res_DE_3,
                           truth = truth)

gg_DD1 <- visualize_fdrtpr(DD_res = res_DD_3[c(mock,genes_to_change_1),], 
                           DE_res = res_DE_3[c(mock,genes_to_change_1),],
                           truth = truth[c(mock,genes_to_change_1),])

gg_DD2 <- visualize_fdrtpr(DD_res = res_DD_3[c(mock,genes_to_change_2),], 
                           DE_res = res_DE_3[c(mock,genes_to_change_2),],
                           truth = truth[c(mock,genes_to_change_2),])

gg_DD3 <- visualize_fdrtpr(DD_res = res_DD_3[c(mock,genes_to_change_3),], 
                           DE_res = res_DE_3[c(mock,genes_to_change_3),],
                           truth = truth[c(mock,genes_to_change_3),])

gg_DD4 <- visualize_fdrtpr(DD_res = res_DD_3[c(mock,genes_to_change_4),], 
                           DE_res = res_DE_3[c(mock,genes_to_change_4),],
                           truth = truth[c(mock,genes_to_change_4),])
gg_all
gg_DD1
gg_DD2
gg_DD3
gg_DD4
```

# sessionInfo

```{r}
sessionInfo()
```

