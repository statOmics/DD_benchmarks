---
title: "Lupus: influence of number of patients - simulation results"
subtitle: "Results for `celltypes = ` `r params$celltype`"
author: "Milan Malfait"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_document:
    theme: flatly # use darkly for dark version
    highlight: tango
    toc: yes
    toc_float: yes
    df_print: paged
    number_sections: false
    code_folding: "hide"
params:
    n_patients: !r c(10, 20, 30)
    methods: !r c("muscat")
    celltype: "ncM"
    prop_DE: 0.05
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  fig.width = 6,
  fig.asp = 0.618,
  out.width = "100%",
  fig.align = "center",
  collapse = TRUE,
  comment = "#>"
)
```

***

```{r libraries, message=FALSE, warning=FALSE, cache=FALSE}
library(here)
library(tidyverse)
theme_set(theme_light())

library(scuttle)
library(iCOBRA)

library(kableExtra)
library(SCandwichCompanion)
```

# Setup

```{r}
## Directory setup
here_root <- "benchmarks/lupus-n_patients"
here::i_am(file.path(here_root, "analysis/lupus-n_patients-sim-results.Rmd"))

res_dir <- here::here(here_root, "results")
fig_dir <- here::here(here_root, "figures")
```

```{r, echo=FALSE, results='asis'}
celltype <- params$celltype

if (!length(celltype) == 1) {
    stop("This report should be run for just 1 celltype only.", call. = FALSE)
}

n_patients <- params$n_patients
methods <- params$methods
prop_DE <- params$prop_DE

cat(
  "\n* Using `n_patients`: ", if (is.null(n_patients)) "missing" else n_patients,
  "\n* Using `methods`: ", paste(methods, collapse = ", "),
  "\n* Using `celltype`: ", celltype,
  "\n* Using `prop_DE`: ", paste(prop_DE, collapse = ", ")
)
```

## Load results

```{r load-results}
# TODO: also add all-patients results for comparison?


res_files <- map(n_patients, ~ get_sim_res_files(
    dataset = "lupus-n_patients",
    methods = methods,
    prop_DE = prop_DE,
    celltype = celltype,
    n_patients = .x
)) %>%
    set_names(paste0("n_patients_", n_patients))

res_list <- map_depth(res_files, 2, readRDS)
str(res_list, max.level = 3)
```

## Load SCE objects

```{r load-SCE-objects}
data_files <- map(n_patients, ~ get_SCE_files(
    dataset = "lupus-n_patients", which = "sim_replicates",
    celltype = celltype, n_patients = .x, prop_DE = prop_DE
)) %>%
    set_names(paste0("n_patients_", n_patients))
sce_objects <- map(data_files, readRDS)
str(sce_objects, max.level = 3)
```


# Data overview {.tabset}

* The results were generated from `r length(sce_objects[[1]])` mock replicates
* Each replicate was generated by randomly splitting the subjects in two mock groups
* No sub-sampling of cells per patient was performed for this data
* DE was introduced by **randomly swapping genes in one of the mock groups**
* The number of patients was randomly sub-sampled stratified by mock group

**Note** that for `n_patients` 10 and 20, the selected patients vary randomly
between the replicates, which is why the `nrows` and `ncols` are not identical.
For the `n_patients` 30, however, no random sub-sampling was done because I
could just use all patients from 2 out of the original 3 batches from the
Control samples. That's why the `ncols` are identical for those subsets.

The mock group assignment of each subject also varies across replicates.

```{r data-overview}
map_dfr(sce_objects,
    ~ map_dfr(.x, function(x) c(nrows = nrow(x), ncols = ncol(x)),
        .id = "replicate"
    ),
    .id = "n_patients"
)
```

Subjects are divided across mock groups as follows:

```{r, include=FALSE}
print_content_with_headings <- function(content,
                                        header_level = 3,
                                        use_names = NULL) {

    if (!is.null(use_names)) {
        names(plotlist) <- use_names
    }

    purrr::iwalk(content, function(x, i) {
        cat("\n\n", paste(rep("#", header_level), collapse = ""), " ",
            i, "\n\n", sep = ""
        )
        print(x)
    })
}
```


## `n_patients = 10` {.tabset}

```{r, results='asis', echo=FALSE}
map(sce_objects$n_patients_10, ~ knitr::kable(table(.x$ind_cov, .x$mock_group))) %>%
    print_content_with_headings()
```

## `n_patients = 20` {.tabset}

```{r, results='asis', echo=FALSE}
map(sce_objects$n_patients_20, ~ knitr::kable(table(.x$ind_cov, .x$mock_group))) %>%
    print_content_with_headings()
```

## `n_patients = 30` {.tabset}

```{r, results='asis', echo=FALSE}
map(sce_objects$n_patients_30, ~ knitr::kable(table(.x$ind_cov, .x$mock_group))) %>%
    print_content_with_headings()
```

The number of DE and non-DE genes per replicate:

```{r}
map(sce_objects, ~ map_dfr(.x, ~ table(rowData(.x)$is_DE), .id = "replicate"))
```

## t-SNE plots {.tabset}

```{r tSNE_plots}
tSNE_plots <- map(sce_objects, function(x) {
    p <- imap(x, function(sce, name) {
        scater::plotTSNE(sce, colour_by = "mock_group") +
            ggtitle(name)
    })
    patchwork::wrap_plots(p, ncol = 3, guides = "collect")
})
```

```{r, results='asis', echo=FALSE}
print_plots(tSNE_plots, use_names = paste("n_patients = ", n_patients))
```


# Extract results of interest

## Runtimes

```{r}
## Get runtimes for each celltype
runtimes <- map_dfr(res_list,
    ~ map_dfr(.x, get_runtimes, depth = 1, .id = "method"),
    .id = "n_patients"
) %>%
    mutate(n_patients = as.numeric(sub("n_patients_", "", n_patients)))
```


## P-values

```{r res_tables}
res_tables <- map_depth(res_list, 2, get_aggregated_rep_tables, depth = 1)
res_tables <- map(res_tables, ~ combine_tables(.x, .id = "method"))
```


# Visualize results

## Run times

```{r runtimes-plot}
ggplot(runtimes, aes(n_patients, time, col = method)) +
    geom_jitter(width = 0.5, alpha = 0.6) +
    geom_smooth(se = FALSE, method = "lm", formula = y ~ x) +
    labs(x = "Number of patients", y = "Time (seconds)", color = NULL) +
    scale_x_continuous(breaks = unique(runtimes$n_patients), minor_breaks = NULL)
```

## P-value distributions for non-DE genes {.tabset}

```{r}
non_de_res <- map2(sce_objects, res_tables, function(sce_list, res) {
    by_rep <- split(res, res$replicate)
    out <- map2(sce_list, by_rep, function(sce, tbl) {
        ## Select only non-DE genes
        non_de <- rownames(sce)[!rowData(sce)$is_DE]
        tbl[tbl$gene %in% non_de, ]
    })
    bind_rows(out, .id = "replicate")
})
```

```{r non-DEpvalue-distributions}
non_de_pval_figs <- map(non_de_res, ~ pval_hist(.x))
```

```{r, results='asis', echo=FALSE, fig.width=12}
print_plots(non_de_pval_figs)
```


# Performance evaluation with `iCOBRA`

## Prepare Data

P-values for missing genes are set to 1.

```{r missing-genes, echo=FALSE, fig.width=16}
tmp_cobra <- map2(res_tables, sce_objects, function(res_table, sce_list) {
    ## Split up results per replicate
    res_per_replicate <- split(res_table, res_table$replicate)
    map2(res_per_replicate, sce_list,
        ~ prepare_COBRAData(.x, .y, replace_missing = FALSE)
    )
})

## Missing genes per method
prop_missing <- map_depth(tmp_cobra, 2,
    ~ map_dbl(pval(.x), ~ mean(is.na(.x)))
) %>%
    map_dfr(~ bind_rows(.x, .id = "replicate"), .id = "n_patients") %>%
    pivot_longer(!c("n_patients", "replicate"), names_to = "method")


## Only make plot if there are non-zero proportion missing values
if (any(prop_missing$value != 0)) {
    prop_missing %>%
        mutate(method = fct_reorder(method, value)) %>%
        ggplot(aes(method, value)) +
            geom_col(show.legend = FALSE) +
            labs(
                x = "Method", y = "Proportion of missing genes",
                title = "Missing genes"
            ) +
            scale_y_continuous(labels = scales::percent, limits = c(0, 1)) +
            coord_flip() +
            facet_grid(rows = vars(n_patients), cols = vars(replicate)) +
            theme_minimal(base_size = 14) +
            theme(panel.grid.major.y = element_blank(),
                  panel.grid.minor = element_blank())
}
```

```{r cobra-prep}
cobra_data <- map2(res_tables, sce_objects, function(res_table, sce_list) {
    ## Split up results per replicate
    res_per_replicate <- split(res_table, res_table$replicate)
    map2(res_per_replicate, sce_list, prepare_COBRAData, replace_missing = TRUE)
})

cobra_perf <- map_depth(cobra_data, 2, calculate_performance, binary_truth = "status")

cobra_objects <- map_depth(cobra_perf, 2, prepare_data_for_plot)
```

## FDR-TPR curves {.tabset}

```{r fdr_tpr-plots}
fdr_tpr_plots <- map(cobra_objects, function(cobra_list) {
    p <- imap(cobra_list, ~ plot_fdrtprcurve(.x, title = .y))
    patchwork::wrap_plots(p, ncol = 3, guides = "collect")
})
```

```{r, echo=FALSE, fig.width=16, results='asis', warning=FALSE}
print_plots(fdr_tpr_plots)
```


## FDR-TPR plots averaged across replicate

```{r fdr_tpr-data}
## Working points
fdr_tpr_points <- map(cobra_objects, combine_fdrtpr_tables) %>%
    bind_rows(.id = "n_patients") %>%
    mutate(n_patients = as.numeric(sub("n_patients_", "", n_patients)))

fdr_tpr_points_averaged <- fdr_tpr_points %>%
    group_by(thr, method, n_patients) %>%
    summarize(across(c(FDR, TPR), mean), .groups = "keep")
```

```{r fdr_tpr-working_points, fig.width=12}
plot_fdrtpr_points(fdr_tpr_points_averaged) +
    facet_wrap(vars(n_patients), labeller = "label_both") +
    xlim(c(0, 0.45)) + ylim(c(0, 1))
```


## FDR control at threshold 0.05

```{r, fig.width=12}
use_thr <- 0.05
fdr_data <- filter(fdr_tpr_points, thr == use_thr)

plot_fdr_control(fdr_data, use_thr = use_thr) +
    ylim(c(0, 1)) +
    facet_wrap(vars(n_patients), labeller = "label_both")
```



# Session info {-}

<details><summary>Session info</summary>

```{r session_info, echo=FALSE, cache=FALSE}
Sys.time()
git2r::repository()
sessioninfo::session_info()
```

</details>
